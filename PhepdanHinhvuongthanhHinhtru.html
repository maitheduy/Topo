<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minh họa Phép Dán: Hình vuông thành Hình trụ</title>
    <style>
        body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; background-color: #1a1a1a; color: #e0e0e0; overflow: hidden; }
        #container { display: flex; width: 100vw; height: 100vh; }
        #info-panel { flex: 0 0 35%; padding: 25px; background-color: #2c2c2c; box-shadow: 2px 0 10px rgba(0,0,0,0.5); overflow-y: auto; display: flex; flex-direction: column; z-index: 10; }
        #canvas-container { flex-grow: 1; position: absolute; top:0; left:0; width:100%; height:100%; }
        h1 { color: #4fc3f7; margin-top: 0; font-size: 1.8em; text-align: center; }
        p { line-height: 1.6; font-size: 1.1em; }
        .control-group { margin-top: 40px; }
        label { font-weight: bold; font-size: 1.2em; }
        .slider-container { display: flex; align-items: center; gap: 15px; margin-top: 10px; }
        .slider-container input[type="range"] { flex-grow: 1; cursor: pointer; }
        #equations { background-color: #333; padding: 15px; border-radius: 8px; margin-top: auto; font-size: 1.0em; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="container">
        <div id="info-panel">
            <h1>Phép Dán: Hình vuông thành Hình trụ</h1>
            <p>
                Mô hình này minh họa phép "dán" tôpô đơn giản nhất. Chúng ta bắt đầu với một hình vuông <strong>[0,1]²</strong> gồm 100,000 điểm.
            </p>
            <p>
                Quy tắc dán là: mỗi điểm ở cạnh dưới <code>(x, 0)</code> được đồng nhất với điểm ở cạnh trên <code>(x, 1)</code>.
            </p>
            <p>
                Kéo thanh trượt để xem hình vuông được uốn cong và dán lại thành một <strong>hình trụ</strong>.
            </p>
            
            <div class="control-group">
                <label for="gluing-slider">Mức độ dán = <span id="gluing-value">0</span>%</label>
                <div class="slider-container">
                    <input type="range" id="gluing-slider" min="0" max="1" value="0" step="0.001">
                </div>
            </div>

            <div id="equations"></div>
        </div>
        <div id="canvas-container"></div>
    </div>

    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.164.1/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/" } } </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls, pointsObject;
        const NUM_POINTS = 100000;
        let initialPoints = []; // Mảng lưu các điểm (u,v) gốc

        const gluingSlider = document.getElementById('gluing-slider');
        const gluingValueSpan = document.getElementById('gluing-value');
        const canvasContainer = document.getElementById('canvas-container');

        // Bước 1: Tạo các điểm gốc một lần duy nhất
        function generateInitialPoints() {
            for (let i = 0; i < NUM_POINTS; i++) {
                initialPoints.push({ u: Math.random(), v: Math.random() });
            }
        }
        
        // Bước 2: Cập nhật hình học dựa trên mức độ dán
        function updateGeometry(gluingFactor) {
            const positions = new Float32Array(NUM_POINTS * 3);
            const radius = 0.5; // Bán kính của hình trụ cuối cùng

            // Áp dụng phép biến đổi cho từng điểm
            for (let i = 0; i < NUM_POINTS; i++) {
                const p = initialPoints[i]; // Lấy điểm gốc (u,v)
                
                // --- PHÉP BIẾN ĐỔI TOÁN HỌC ---
                // u: chiều ngang của hình vuông -> sẽ uốn thành vòng tròn
                // v: chiều dọc của hình vuông -> sẽ là chiều cao của hình trụ
                const angle = p.u * 2 * Math.PI; // Góc cuối cùng trên hình tròn

                // Tọa độ của điểm trên hình vuông phẳng (t=0)
                const x_flat = p.u - 0.5;
                const z_flat = 0;

                // Tọa độ của điểm trên hình trụ (t=1)
                const x_cylinder = radius * Math.cos(angle);
                const z_cylinder = radius * Math.sin(angle);
                
                // Nội suy tuyến tính giữa hai trạng thái dựa trên gluingFactor (t)
                const t = gluingFactor;
                const x = (1 - t) * x_flat + t * x_cylinder;
                const y = p.v - 0.5; // Chiều cao không đổi
                const z = (1 - t) * z_flat + t * z_cylinder;

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
            }
            
            // Cập nhật thuộc tính 'position' của geometry
            pointsObject.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            pointsObject.geometry.attributes.position.needsUpdate = true;
            pointsObject.geometry.computeBoundingSphere(); // Cần thiết để camera hoạt động đúng
        }
        
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 100);
            camera.position.set(0, 0, 1.5);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            canvasContainer.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            
            scene.add(new THREE.AmbientLight(0xffffff, 1.0));

            // Tạo các điểm và đối tượng hình học ban đầu
            generateInitialPoints();
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.PointsMaterial({ color: 0x76ff03, size: 0.005 });
            pointsObject = new THREE.Points(geometry, material);
            scene.add(pointsObject);

            // Cập nhật hình học lần đầu ở trạng thái phẳng
            updateGeometry(0);
            
            // --- Event Listeners ---
            gluingSlider.addEventListener('input', (e) => {
                const factor = parseFloat(e.target.value);
                gluingValueSpan.textContent = Math.round(factor * 100);
                updateGeometry(factor);
            });
            
            window.addEventListener('resize', () => {
                camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            });
            
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
        }

        init();
    </script>
</body>
</html>